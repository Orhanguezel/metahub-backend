import fs from "fs/promises";
import path from "path";
import fsSync from "fs";
import type { Router } from "express";
import { scanExpressRouter } from "./scanExpressRouter";

/**
 * Modules klas√∂r√ºndeki index.ts dosyalarƒ±nƒ± import edip router i√ßindeki endpoint‚Äôleri tarar,
 * OpenAPI 3.0 spec olu≈üturur.
 *
 * Kurallar:
 * - Base path: `${API_PREFIX}/${moduleName}`
 * - Varsayƒ±lan security: bearerAuth (JWT)
 * - Path i√ßinde `/public` veya `/open` ge√ßiyorsa security bo≈ü (public)
 * - Her endpoint‚Äôte zorunlu header: x-tenant (√∂r: gzl)
 */

function isExpressRouterInstance(x: any): x is Router {
  return !!x && typeof x === "function" && typeof x.use === "function" && typeof x.handle === "function";
}

function maybeCreateRouter(def: any): Router | undefined {
  // 1) Halihazƒ±rda Router instance mƒ±?
  if (isExpressRouterInstance(def)) return def;

  // 2) Factory fonksiyon mu? (stack/handle yok ‚Üí √ßaƒüƒ±r)
  if (typeof def === "function" && !def.handle && !def.stack) {
    const r = def();
    if (isExpressRouterInstance(r)) return r;
  }

  // 3) Nesne olarak export edilmi≈ü ama handle/use var
  if (def && typeof def.use === "function" && typeof def.handle === "function") {
    return def as Router;
  }

  return undefined;
}

export async function generateSwaggerFromRouters(writeToDisk = false) {
  const modulesRoot = path.resolve(__dirname, "..", "..", "modules");
  const apiPrefix = process.env.SWAGGER_API_PREFIX || "/api";
  const brand = process.env.BRAND_NAME || "MetaHub";
  const profile = process.env.APP_ENV || "dev";
  const apiVersion = process.env.API_VERSION || "1.0.0";
  const baseUrl = process.env.SWAGGER_BASE_URL || "http://localhost:5019";

  if (!fsSync.existsSync(modulesRoot)) {
    console.warn(`‚ö†Ô∏è Modules folder not found at: ${modulesRoot}`);
    return undefined;
  }

  // Mod√ºl klas√∂rleri
  const dirents = await fs.readdir(modulesRoot, { withFileTypes: true });
  const modules = dirents
    .filter((d) => d.isDirectory())
    .map((d) => d.name)
    .sort((a, b) => a.localeCompare(b));

  const tags: Array<{ name: string; description?: string }> = [];
  const paths: Record<string, any> = {};

  for (const moduleName of modules) {
    const importPathNoExt = path.join(modulesRoot, moduleName, "index.ts").replace(/\.ts$/, "");

    // Mod√ºl router‚Äôƒ±nƒ± import et
    let modRouter: Router | undefined;
    try {
      const indexImport = await import(importPathNoExt);
      const def = indexImport?.default;

      modRouter = maybeCreateRouter(def);

      if (!modRouter) {
        console.warn(`‚ö†Ô∏è ${moduleName}: index.ts default export Router deƒüil. Atlandƒ±.`);
        continue;
      }
    } catch (err: any) {
      console.warn(`‚ö†Ô∏è ${moduleName}: index.ts import edilemedi. (${err?.message || err})`);
      continue;
    }

    // Mod√ºl i√ß rotalarƒ±nƒ± tara (mod bazƒ±nda try/catch)
    let moduleRoutes = [];
    try {
      moduleRoutes = scanExpressRouter(modRouter);
    } catch (e: any) {
      console.warn(`‚ö†Ô∏è ${moduleName}: router scan sƒ±rasƒ±nda hata: ${e?.message || e}`);
      continue;
    }

    if (moduleRoutes.length === 0) {
      console.warn(`‚ö†Ô∏è ${moduleName}: router i√ßinde endpoint bulunamadƒ±. Atlandƒ±.`);
      continue;
    }

    // Tag ekle
    tags.push({ name: moduleName, description: `${moduleName} endpoints` });

    // Her route ‚Üí OpenAPI path
    for (const r of moduleRoutes) {
      const fullPath = `${apiPrefix}/${moduleName}${r.path}`.replace(/\/{2,}/g, "/");
      const method = r.method.toLowerCase();

      if (!paths[fullPath]) paths[fullPath] = {};

      const isPublic = /\/(public|open)(\/|$)/i.test(fullPath);

      const pathSpec: any = {
        tags: [moduleName],
        summary: "",
        deprecated: false,
        security: isPublic ? [] : [{ bearerAuth: [] }],
        parameters: [
          {
            name: "x-tenant",
            in: "header",
            required: true,
            schema: { type: "string", example: "gzl" },
            description: "Tenant kimliƒüi (zorunlu).",
          },
        ],
        responses: {
          200: { description: "Success" },
        },
      };

      paths[fullPath][method] = pathSpec;
    }
  }

  const spec = {
    openapi: "3.0.0",
    info: {
      title: `${brand} Backend API`,
      version: apiVersion,
      description: `üìò API documentation generated by router scanning (${profile}).`,
      contact: {
        name: `${brand} Support`,
        email: process.env.CONTACT_EMAIL || "support@example.com",
        url: process.env.CONTACT_URL || "https://example.com",
      },
      license: {
        name: "MIT",
        url: "https://opensource.org/licenses/MIT",
      },
    },
    servers: [
      {
        url: baseUrl,
        description: `Base URL for ${profile}`,
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT",
        },
      },
      parameters: {
        TenantHeader: {
          name: "x-tenant",
          in: "header",
          required: true,
          schema: { type: "string", example: "gzl" },
          description: "Tenant kimliƒüi (zorunlu).",
        },
      },
    },
    security: [],
    tags,
    paths,
  };

  if (writeToDisk) {
    const outputPath = path.join(process.cwd(), "swagger.json");
    await fs.writeFile(outputPath, JSON.stringify(spec, null, 2));
    console.log(`üìÑ Swagger spec written to: ${outputPath}`);
  }

  console.log(`‚úÖ Swagger generated by router scan. modules=${modules.length}, tags=${tags.length}`);
  return spec;
}
